# Sceptre 2.0

This document contains proposals for API changes that will be made to Sceptre for its version 2.0 release. This document is a work in progress.

Proposals use the following syntax:
```
### <name>

#### Implementation

#### Pros
-

#### Cons
-
```

## Proposals


### 00 Simplify create, update, delete, launch, describe CLI commands

We currently build stacks and environments with the syntax:

```
sceptre <action>-stack env stack
sceptre <action>-env env
```

This proposal would change this to:

```
sceptre <action> path/to/stack.yaml
sceptre <action> --recursive path/to/env/
```

#### Implementation

Rename CLI commands.

#### Pros
- The `--recursive` syntax is more in keeping with Unix standards (e.g. `cp`, `mv`, `grep`)
- By supplying file paths, we get native tab completion (only tested on `zsh` on `macOS`)
- Commands are less verbose

#### Cons
- The original reason for having separate commands for building stacks and environments was to avoid users accidentally deleting whole environments. This would be mitigated by proposal 01.


### 01 Add a user confirmation to delete

Sceptre should ask for user confirmation when deleting stacks or environments. A CLI flag `--yes/-y` will be added, allowing scriptable deletion of resources. This confirmation will only happen on the CLI, not when delete commands are run from Python.

#### Implementation

Add [confirmation prompts](http://click.pocoo.org/5/prompts/#confirmation-prompts) with Click.

#### Pros
- Syntax is in keeping with Unix standards (e.g. `yum install`)

#### Cons
-


### 02 Stacks as first-class citizens

Its difficult to instantiate Stack objects directly. In the Sceptre code base, we instantiate Stacks by instantiating their surrounding Environments, which create the stacks for us. Moving to a first-class citizen stack model, where we can interact with stacks directly would

#### Implementation

Instantiating a Stack requires passing it environment config and a connection manager. These objects would have to be instantiated within the Stack.

#### Pros
- Improves Sceptre's Python API
- Each stack instantiating its own connection manager may make multithreading easier

#### Cons
- If each stack in an environment instantiates its own connection manager, we may have to enter an MFA code for each stack, rather than a single one for the environment
- Inefficient if each stack in an environment reads in environment config
- The above two points may be mitigated if Stack optionally accepts environment config and a connection manager, and instantiates them itself if they aren't passed through.


### 03 Remove official support for Sceptre use as a Python module

Sceptre officially supports use via the CLI and as a Python module. Use via the CLI is far more common (I'm not sure if anyone uses Sceptre as a Python module). We guarantee that both our CLI and public Python APIs won't change. Guaranteeing the Python API leads to two problems:

- It makes it difficult to refactor the inner workings of Sceptre
- It makes our versioning unusual, as we are effectively versioning two independent APIs with a single version number. If we commit a breaking change to Sceptre's Python internals, we must bump our major version number, even though users of Sceptre as a CLI tool (most of our users) would see no change.

This would be a relatively superficial change. Our Python function and classes would still be public, and people could still use Sceptre as a module, but we wouldn't officially support it or guarantee its API.

#### Implementation

Remove references to use as a Python module from the documentation.

#### Pros
- Reduces our public API
- Makes it easier to develop Sceptre as we have fewer contracts to uphold
- Makes our versioning less strange

#### Cons
- Discontinued support for Python module


### 04 Remove cascading config for stack config files

Stack config files support [cascading config](http://sceptre.cloudreach.com/docs/environment_config.html#id1). This is mainly used for reducing repeated config when launching the same stack in multiple environments, such as launching a stack which enables CloudTrail in each region.

The following problems stem from cascading stack config:

1. It makes it impossible to launch stacks which are contained in an environment which also contains a sub environment.

  Given the following sceptre project:
  ```
  .
  └── config
      └── dev
          ├── ew1
          │   └── vpc.yaml
          └── vpc.yaml
  ```
  We have no way of knowing whether `dev/vpc.yaml` is a stack in its own right, or if it's an incomplete stack that `dev/ew1/vpc.yaml` completes. When we run `launch-env`, we have to exclude `dev/vpc.yaml`.
2. Using cascaded stack config can lead to complex environments with lots of empty files:

  ```
  .
  └── config
      └── dev
          ├── ew1
          │   └── cloud_trail.yaml  # empty file
          ├── ew2
          │   └── cloud_trail.yaml  # empty file
          ├── ...
          └── cloud_trail.yaml
  ```
  If there are lots of cascaded stack config files, it can be difficult to reason where config items are set.
3. Cascading config for stacks is poorly implemented, and a better implementation would introduce complexity.

  Stack config items, such as `sceptre_user_data` can be nested. Cascaded config currently replaces the whole item:
  ```
  # dev/cloud_trail.yaml
  ...
  sceptre_user_data:  # All of these items are overwritten, even though users may think that only repeated_param should be overwritten
    repeated_param: old_value
    unique_param: value

  ---

  # dev/ew1/cloud_trail.yaml
  ...
  sceptre_user_data:
    repeated_param: new_value

  ```

I think the benefits of cascaded stack config are outweighed by the negatives.

#### Implementation

#### Pros
- Fixes problems listed above
- Reduces Sceptre complexity

#### Cons
- Removes a feature


### 05 Remove the word "stack" from CLI commands

If we implement [00], then we can also remove the word "stack" from the following commands:

```
describe-stack-outputs
get-stack-policy
lock-stack
set-stack-policy
unlock-stack
update-stack-cs
```

#### Implementation

Easy, change the name of the command in `cli.py`.

#### Pros
- Simplifies CLI API

#### Cons
- Less explicit
